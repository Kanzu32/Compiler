dim aa1 %;
aa1 ass 1;
if (aa1 = 1) {
    aa1 ass aa1 + 1;
} elseif (aa1 < 0) {
    aa1 ass -9;
} else {
    aa1 ass 0;
};
/*


input()
for (ii1 ass 1 to 5) {}
ii1 1 ass 5 [M] for [3 параметра идентификатор, граница, метка]

если for - след. ID - target
              (M1) НЕТ - [END]
for (ii1 ass 1 to 5) {
    ""
    [M1]
}
(END)

ii1 1 ass (M1) ii1 5 [END] for "" [M1] (END)

do while (ii1 > 0) {}

(M1) ii1 0 > [END] while "" [M1] (END)


M1
dim ii1, ii2 %
ii1 ii1 , % dim [2 аргумента список, тип]

ii1 5 + ii1 0 = [M1] if ii1 ii1 5 * ass (M1)

усл метка if

STACK:

; сворачивает до { или конца стека
if - счёт нужной метки
} записывает прыжок на метку выхода из конструкции или для зацикливания [M1] jmp и после ставит метку (M2) (из ещё одного стека?)
[M1] jmp прыжок на метку

[M1] метка для прыжка
(M1) метка для перехода на неё
|ii1 ii2| список идентификаторов

to, do - мусор

+ - * / < > <= >= = !=  [5 5]
and or not

; ) }                   [0 -]

(                       [2 0<x<5]
{                       [0 0<x<5]

if for while else       [- 1]
elseif

ass                     [1 1]

read output             [2 2]
dim                     [2 2]
,                       [5 5]



if !усл jmp M1
{

конец jmp EXIT [] - оставить пустую метку
} M1
elseif !усл M2
{

конец jmp EXIT []
} M2
else
{

конец jmp EXIT []
} EXIT - после } после которой нет else, elseif пройтись про результату и прописать все метки.